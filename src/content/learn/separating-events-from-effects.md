---
title: 'ã‚¤ãƒ™ãƒ³ãƒˆã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åˆ‡ã‚Šé›¢ã™'
---

<Intro>

ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¯åŒã˜ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’å†åº¦å®Ÿè¡Œã—ãŸå ´åˆã®ã¿å†å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨ã¯ç•°ãªã‚Šã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„ state å¤‰æ•°ã®ã‚ˆã†ãªèª­ã¿å–ã£ãŸå€¤ãŒã€å‰å›ã®ãƒ¬ãƒ³ãƒ€ãƒ¼æ™‚ã®å€¤ã¨ç•°ãªã‚‹å ´åˆã«å†åŒæœŸã‚’è¡Œã„ã¾ã™ã€‚ã¾ãŸã€ã‚ã‚‹å€¤ã«ã¯åå¿œã—ã¦å†å®Ÿè¡Œã™ã‚‹ãŒã€ä»–ã®å€¤ã«ã¯åå¿œã—ãªã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã©ã€ä¸¡æ–¹ã®å‹•ä½œã‚’ãƒŸãƒƒã‚¯ã‚¹ã•ã›ãŸã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ã€ãã®æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

</Intro>

<YouWillLearn>

- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é¸æŠæ–¹æ³•
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãŒãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„ç†ç”±
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ã®ä¸€éƒ¨ã‚’ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ãªã„å ´åˆã®å¯¾å‡¦æ³•
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¨ã¯ä½•ã‹ã€ãã—ã¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æŠ½å‡ºã™ã‚‹æ–¹æ³•
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‹ã‚‰æœ€æ–°ã® props ã¨ state ã‚’èª­ã¿å–ã‚‹æ–¹æ³•

</YouWillLearn>

## ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã©ã¡ã‚‰ã‚’é¸ã¶ã‹ {/*choosing-between-event-handlers-and-effects*/}

ã¾ãšã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é•ã„ã«ã¤ã„ã¦ãŠã•ã‚‰ã„ã—ã¾ã—ã‚‡ã†ã€‚

ãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚è¦ä»¶ã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ï¼š

1. ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯é¸æŠã•ã‚ŒãŸãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã«è‡ªå‹•çš„ã«æ¥ç¶šã™ã‚‹
2. ã€ŒSendã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãƒãƒ£ãƒƒãƒˆã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé€ä¿¡ã•ã‚Œã‚‹

ã‚ãªãŸã¯ãã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã¯ã™ã§ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŒã€ãã‚Œã‚’ã©ã“ã«ç½®ãã‹è¿·ã£ã¦ã„ã‚‹ã¨ã—ã¾ã—ã‚‡ã†ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ä½¿ã†ã¹ãã‹ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ã¹ãã‹ã€‚ã“ã®è³ªå•ã«ç­”ãˆã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã³ã«ã€[ãªãœãã®ã‚³ãƒ¼ãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ã‚’è€ƒãˆã¦ã¿ã¦ãã ã•ã„ã€‚](/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events)

### ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã«åå¿œã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© {/*event-handlers-run-in-response-to-specific-interactions*/}

ãƒ¦ãƒ¼ã‚¶ã®ç«‹å ´ã‹ã‚‰ã™ã‚‹ã¨ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã¯ã€ç‰¹å®šã®ã€Œé€ä¿¡ã€ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‹ã‚‰èµ·ã“ã‚‹ã¯ãšã§ã™ã€‚ãã‚Œä»¥å¤–ã®æ™‚é–“ã‚„ç†ç”±ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹ã¨ã€ãƒ¦ãƒ¼ã‚¶ã¯ã‚€ã—ã‚æ€’ã‚‹ã§ã—ã‚‡ã†ã€‚ãã®ãŸã‚ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã§è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ä½¿ãˆã°ã€ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š

```js {4-6}
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}
```

ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ä½¿ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãŒãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã¨ãã ã‘ `sendMessage(message)` ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### åŒæœŸãŒå¿…è¦ãªã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ {/*effects-run-whenever-synchronization-is-needed*/}

ã¾ãŸã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã«æ¥ç¶šã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚ãã®ã‚³ãƒ¼ãƒ‰ã¯ã©ã“ã«è¨˜è¿°ã•ã‚Œã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ç†ç”±ã¯ã€ä½•ã‹ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¦ãƒ¼ã‚¶ãŒãªãœã€ã©ã®ã‚ˆã†ã«ãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã®ç”»é¢ã«ç§»å‹•ã—ãŸã‹ã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¦ãƒ¼ã‚¶ãŒãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã®ç”»é¢ã‚’è¦‹ã¦ã€å¯¾è©±ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸä»Šã€ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€é¸æŠã•ã‚ŒãŸãƒãƒ£ãƒƒãƒˆã‚µãƒ¼ãƒã«æ¥ç¶šã•ã‚ŒãŸã¾ã¾ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ ãƒ»ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚¢ãƒ—ãƒªã®åˆæœŸç”»é¢ã§ã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãŒä½•ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚‚è¡Œã£ã¦ã„ãªã„å ´åˆã§ã‚‚ã€æ¥ç¶šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚ŒãŒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ç†ç”±ã§ã™ï¼š

```js {3-9}
function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ¦ãƒ¼ã‚¶ãŒè¡Œã£ãŸç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã«é–¢ä¿‚ãªãã€ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒãƒ£ãƒƒãƒˆã‚µãƒ¼ãƒã¸ã®æ¥ç¶šãŒå¸¸ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãŒã‚¢ãƒ—ãƒªã‚’é–‹ã„ãŸã ã‘ã§ã‚ã‚ã†ã¨ã€åˆ¥ã®éƒ¨å±‹ã‚’é¸ã‚“ã ã ã‘ã§ã‚ã‚ã†ã¨ã€åˆ¥ã®ç”»é¢ã«ç§»å‹•ã—ã¦æˆ»ã£ã¦ããŸã ã‘ã§ã‚ã‚ã†ã¨ã€ã“ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹éƒ¨å±‹ã¨åŒæœŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã€[å¿…è¦ãªã¨ãã¯ã„ã¤ã§ã‚‚å†æ¥ç¶šã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚](/learn/lifecycle-of-reactive-effects#why-synchronization-may-need-to-happen-more-than-once)

<Sandpack>

```js
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  function handleSendClick() {
    sendMessage(message);
  }

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

```js chat.js
export function sendMessage(message) {
  console.log('ğŸ”µ You sent: ' + message);
}

export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('âœ… Connecting to "' + roomId + '" room at ' + serverUrl + '...');
    },
    disconnect() {
      console.log('âŒ Disconnected from "' + roomId + '" room at ' + serverUrl);
    }
  };
}
```

```css
input, select { margin-right: 20px; }
```

</Sandpack>

## ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ã¨ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ {/*reactive-values-and-reactive-logic*/}

ç›´æ„Ÿçš„ã«è¨€ã†ã¨ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¯ã€ä¾‹ãˆã°ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ãªã©ã€å¸¸ã«ã€Œæ‰‹å‹•ã€ã§ãƒˆãƒªã‚¬ã•ã‚Œã¾ã™ã€‚ä¸€æ–¹ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€Œè‡ªå‹•ã€ã§ã‚ã‚Šã€åŒæœŸã‚’ä¿ã¤ãŸã‚ã«å¿…è¦ãªå›æ•°ã ã‘å®Ÿè¡Œã•ã‚Œã€å†å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

ã‚‚ã£ã¨æ­£ç¢ºãªè€ƒãˆæ–¹ãŒã‚ã‚Šã¾ã™ã€‚

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã® body å†…ã§å®£è¨€ã•ã‚ŒãŸ props ã€state ã€å¤‰æ•°ã‚’<CodeStep step={2}>ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤</CodeStep>ã¨å‘¼ã³ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€`serverUrl` ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€`roomId` ã¨ `message` ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã«å‚åŠ ã—ã¦ã„ã¾ã™ï¼š

```js [[2, 3, "roomId"], [2, 4, "message"]]
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}
```
ã“ã‚Œã‚‰ã®ã‚ˆã†ãªãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ã¯ã€å†ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ã‚ˆã£ã¦å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãŒ `message` ã‚’ç·¨é›†ã—ãŸã‚Šã€ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã§åˆ¥ã® `roomId` ã‚’é¸æŠã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€ãã‚Œãã‚Œç•°ãªã‚‹æ–¹æ³•ã§å¤‰åŒ–ã«å¯¾å¿œã—ã¾ã™ï¼š

- **ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©å†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ã€‚**ãƒ¦ãƒ¼ã‚¶ãŒåŒã˜æ“ä½œï¼ˆã‚¯ãƒªãƒƒã‚¯ãªã©ï¼‰ã‚’å†åº¦è¡Œã‚ãªã„é™ã‚Šã€å†åº¦å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¯ã€ãã®å¤‰æ›´ã«ã€Œåå¿œã€ã™ã‚‹ã“ã¨ãªãã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã‚’èª­ã¿å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã€‚**ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã‚’èª­ã¿å–ã‚‹å ´åˆã€[ä¾å­˜é…åˆ—ã¨ã—ã¦ãã‚Œã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚](/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values)ãã—ã¦ã€å†ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ã‚ˆã£ã¦ãã®å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€React ã¯æ–°ã—ã„å€¤ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†å®Ÿè¡Œã—ã¾ã™ã€‚ 

ã“ã®é•ã„ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€å…ˆã»ã©ã®ä¾‹ã‚’ã‚‚ã†ä¸€åº¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©å†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ {/*logic-inside-event-handlers-is-not-reactive*/}

ã“ã®ã‚³ãƒ¼ãƒ‰ã®è¡Œã‚’è¦‹ã¦ã¿ã¦ãã ã•ã„ã€‚ã“ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ã€ãã†ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

```js [[2, 2, "message"]]
    // ...
    sendMessage(message);
    // ...
```

ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰è¦‹ã‚Œã°ã€**`message` ã®å¤‰æ›´ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚ŠãŸã„ã¨ã„ã†ã“ã¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**ã‚ãã¾ã§ã‚‚ã€ãƒ¦ãƒ¼ã‚¶ãŒå…¥åŠ›ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã£ã¦ã¯ãªã‚‰ãªã„ã®ã§ã™ã€‚<CodeStep step={2}>ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤</CodeStep>ãŒå¤‰ã‚ã£ãŸã‹ã‚‰ã¨è¨€ã£ã¦ã€å†ã³å®Ÿè¡Œã•ã‚Œã‚‹ã¹ãã§ã¯ãªã„ã®ã§ã™ã€‚ã ã‹ã‚‰ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ä¸­ã«ã‚ã‚‹ã®ã§ã™ï¼š

```js {2}
  function handleSendClick() {
    sendMessage(message);
  }
```

ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ã®ã§ã€`sendMessage(message)`ã¯ãƒ¦ãƒ¼ã‚¶ãŒé€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®ã¿å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ {/*logic-inside-effects-is-reactive*/}

ã§ã¯ã€ã“ã®è¡Œã«æˆ»ã‚Šã¾ã—ã‚‡ã†ï¼š

```js [[2, 2, "roomId"]]
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    // ...
```

ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰ã™ã‚‹ã¨ã€**`roomId` ã®å¤‰æ›´ã¯ã€åˆ¥ã®éƒ¨å±‹ã«æ¥ç¶šã—ãŸã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚**ã¤ã¾ã‚Šã€ãƒ«ãƒ¼ãƒ ã«æ¥ç¶šã™ã‚‹ãŸã‚ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã¹ããªã®ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚³ãƒ¼ãƒ‰ã¯ã€<CodeStep step={2}>ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤</CodeStep>ã«ã€Œã¤ã„ã¦ã„ã‘ã‚‹ã€ã‚ˆã†ã«ã—ã€ãã®å€¤ãŒç•°ãªã‚‹å ´åˆã¯å†åº¦å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã ã‹ã‚‰ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸­ã«ã‚ã‚‹ã®ã§ã™ï¼š

```js {2-3}
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId]);
```

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã®ã§ã€`createConnection(serverUrl, roomId)` ã¨ `connection.connect()` ã¯ã€`roomId` ã®ç•°ãªã‚‹å€¤ã”ã¨ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã€ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒ«ãƒ¼ãƒ ã«åŒæœŸã—ãŸãƒãƒ£ãƒƒãƒˆæ¥ç¶šã‚’ç¶­æŒã—ã¾ã™ã€‚

## ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‹ã‚‰éãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æŠ½å‡ºã™ã‚‹ {/*extracting-non-reactive-logic-out-of-effects*/}

ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã¨éãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æ··åœ¨ã•ã›ã‚‹å ´åˆã¯ã€ã•ã‚‰ã«å„ä»‹ãªã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ä¾‹ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãŒãƒãƒ£ãƒƒãƒˆã«æ¥ç¶šã—ãŸã¨ãã«é€šçŸ¥ã‚’è¡¨ç¤ºã—ãŸã„ã¨ã—ã¾ã™ã€‚props ã‹ã‚‰ç¾åœ¨ã®ãƒ†ãƒ¼ãƒï¼ˆãƒ€ãƒ¼ã‚¯ã¾ãŸã¯ãƒ©ã‚¤ãƒˆï¼‰ã‚’èª­ã¿å–ã‚Šã€æ­£ã—ã„è‰²ã§é€šçŸ¥ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š

```js {1,4-6}
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    // ...
```

ã—ã‹ã—ã€`theme` ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ã§ã‚ã‚Šï¼ˆå†ãƒ¬ãƒ³ãƒ€ãƒ¼ã®çµæœã¨ã—ã¦å¤‰åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰ã€[ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒèª­ã¿å–ã‚‹ã™ã¹ã¦ã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã¯ã€ãã®ä¾å­˜é…åˆ—ã¨ã—ã¦å®£è¨€ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚](/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency)ãã“ã§ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾å­˜é…åˆ—ã¨ã—ã¦ `theme` ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š

```js {5,11}
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId, theme]); // âœ… All dependencies declared
  // ...
```

ã“ã®ä¾‹ã§éŠã‚“ã§ã¿ã¦ã€ã“ã®ãƒ¦ãƒ¼ã‚¶ã‚¨ã‚¯ã‚¹ãƒšãƒªã‚¨ãƒ³ã‚¹ã®å•é¡Œç‚¹ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã©ã†ã‹ç¢ºèªã—ã¦ãã ã•ã„ï¼š

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

```js chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Only "connected" event is supported.');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

```js notifications.js
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```css
label { display: block; margin-top: 10px; }
```

</Sandpack>

`roomId` ãŒå¤‰ã‚ã‚‹ã¨ã€æœŸå¾…é€šã‚Šãƒãƒ£ãƒƒãƒˆãŒå†æ¥ç¶šã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€`theme` ã‚‚ä¾å­˜é–¢ä¿‚ã«ã‚ã‚‹ãŸã‚ã€ãƒ€ãƒ¼ã‚¯ã¨ãƒ©ã‚¤ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ãŸã³ã«ã€ãƒãƒ£ãƒƒãƒˆã‚‚å†æ¥ç¶šã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã‚ã¾ã‚Šè‰¯ããªã„ã§ã™ã­ï¼

ã¤ã¾ã‚Šã€ã“ã®è¡Œã¯ï¼ˆãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ï¼‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸­ã«ã‚ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã£ã¦ã»ã—ããªã„ã¨ã„ã†ã“ã¨ã§ã™ï¼š

```js
      // ...
      showNotification('Connected!', theme);
      // ...
```

ã“ã®éãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã¨ã€ãã®å‘¨ã‚Šã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åˆ‡ã‚Šé›¢ã™æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã®å®£è¨€ {/*declaring-an-effect-event*/}

<Wip>

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã¾ã å®‰å®šç‰ˆã® React ã§**ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¦ã„ãªã„å®Ÿé¨“çš„ãª API** ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚

</Wip>

[`useEffectEvent`](/reference/react/experimental_useEffectEvent) ã¨ã„ã†ç‰¹åˆ¥ãª Hook ã‚’ä½¿ã£ã¦ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‹ã‚‰ã“ã®éãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’æŠ½å‡ºã—ã¾ã™ï¼š

```js {1,4-6}
import { useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });
  // ...
```

ã“ã“ã§ã¯ã€`onConnected` ã¯*ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ*ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã®ä¸€éƒ¨ã§ã™ãŒã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã«ã‚ˆã‚Šè¿‘ã„å‹•ä½œã‚’ã—ã¾ã™ã€‚ã“ã®ä¸­ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ãªãã€å¸¸ã« props ã¨ state ã®æœ€æ–°ã®å€¤ã‚’ã€Œè¦‹ã‚‹ã€ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã‚Œã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†…éƒ¨ã‹ã‚‰ `onConnected` ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼š

```js {2-4,9,13}
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // âœ… All dependencies declared
  // ...
```

ã“ã‚Œã§å•é¡Œã¯è§£æ±ºã—ã¾ã—ãŸã€‚ãªãŠã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾å­˜é…åˆ—ã®ãƒªã‚¹ãƒˆã‹ã‚‰ `onConnected` ã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚**ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ãªã„ã®ã§ã€ä¾å­˜é…åˆ—ã‹ã‚‰é™¤å¤–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚**

æ–°ã—ã„å‹•ä½œãŒæœŸå¾…é€šã‚Šã«æŒ¯èˆã†ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ï¼š

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

```js chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Only "connected" event is supported.');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

```js notifications.js hidden
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```css
label { display: block; margin-top: 10px; }
```

</Sandpack>

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¨éå¸¸ã«ä¼¼ã¦ã„ã‚‹ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸»ãªé•ã„ã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãŒãƒ¦ãƒ¼ã‚¶ã®æ“ä½œã«åå¿œã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã®ã«å¯¾ã—ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒˆãƒªã‚¬ã•ã‚Œã‚‹ã“ã¨ã§ã™ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ€§ã¨åå¿œã—ãªã„ã¯ãšã®ã‚³ãƒ¼ãƒ‰ã¨ã®é–“ã®ã€Œé€£é–ã‚’æ–­ã¡åˆ‡ã‚‹ã€ã“ã¨ãŒã§ãã¾ã™ã€‚

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã§æœ€æ–°ã® props ã‚„ state ã‚’å–å¾—ã™ã‚‹ {/*reading-latest-props-and-state-with-effect-events*/}

<Wip>

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã¾ã å®‰å®šç‰ˆã® React ã§**ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¦ã„ãªã„å®Ÿé¨“çš„ãª API** ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚

</Wip>

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã«ã‚ˆã£ã¦ã€ä¾å­˜æ€§ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã—ãŸããªã‚‹ã‚ˆã†ãªå¤šãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¾‹ãˆã°ã€ãƒšãƒ¼ã‚¸ã®è¨ªå•ã‚’è¨˜éŒ²ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒã‚ã‚‹ã¨ã—ã¾ã™ï¼š

```js
function Page() {
  useEffect(() => {
    logVisit();
  }, []);
  // ...
}
```

ãã®å¾Œã€ã‚µã‚¤ãƒˆã«è¤‡æ•°ã®ãƒ«ãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚ã“ã“ã§ã€`Page` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ç¾åœ¨ã®ãƒ‘ã‚¹ã‚’æŒã¤ `url` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ã“ã® `url` ã‚’ `logVisit` å‘¼ã³å‡ºã—ã®ä¸€éƒ¨ã¨ã—ã¦æ¸¡ã—ãŸã„ã®ã§ã™ãŒã€ä¾å­˜æ€§ãƒªãƒ³ã‚¿ãŒæ–‡å¥ã‚’è¨€ã£ã¦ãã¾ã™ï¼š

```js {1,3}
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, []); // ğŸ”´ React Hook useEffect has a missing dependency: 'url'
  // ...
}
```

ã‚³ãƒ¼ãƒ‰ã«ä½•ã‚’ã•ã›ãŸã„ã‹è€ƒãˆã¦ã¿ã¦ãã ã•ã„ã€‚å„ URL ã¯ç•°ãªã‚‹ãƒšãƒ¼ã‚¸ã‚’è¡¨ã—ã¦ã„ã‚‹ã®ã§ã€ç•°ãªã‚‹ URL ã«å¯¾ã—ã¦åˆ¥ã€…ã®è¨ªå•ã‚’è¨˜éŒ²*ã—ãŸã„ã®ã§ã™*ã€‚è¨€ã„æ›ãˆã‚Œã°ã€ã“ã® `logVisit` å‘¼ã³å‡ºã—ã¯ã€`url` ã«é–¢ã—ã¦åå¿œçš„ã§*ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“*ã€‚ã“ã®ãŸã‚ã€ã“ã®å ´åˆã¯ã€ä¾å­˜é–¢ä¿‚ãƒªãƒ³ã‚¿ã«å¾“ã£ã¦ã€`url` ã‚’ä¾å­˜é…åˆ—ã«è¿½åŠ ã™ã‚‹ã“ã¨ãŒç†ã«ã‹ãªã£ã¦ã„ã¾ã™ï¼š

```js {4}
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, [url]); // âœ… å…¨ã¦ã®ä¾å­˜å€¤ãŒå®£è¨€ã•ã‚Œã¦ã„ã¾ã™
  // ...
}
```

ã“ã“ã§ã€ãƒšãƒ¼ã‚¸è¨ªå•ã”ã¨ã«ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆã®å•†å“æ•°ã‚’ä¸€ç·’ã«è¡¨ç¤ºã•ã›ãŸã„ã¨ã—ã¾ã™ï¼š

```js {2-3,6}
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
  }, [url]); // ğŸ”´ React Hookã®useEffectã«ä¾å­˜å€¤'numberOfItems'ãŒã‚ã‚Šã¾ã›ã‚“
  // ...
}
```

ã‚ãªãŸã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸­ã§ `numberOfItems` ã‚’ä½¿ç”¨ã—ãŸã®ã§ã€ãƒªãƒ³ã‚¿ã¯ä¾å­˜å€¤ã¨ã—ã¦ãã‚Œã‚’è¿½åŠ ã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã¾ã™ã€‚ã—ã‹ã—ã€`logVisit` ã®å‘¼ã³å‡ºã—ãŒ `numberOfItems` ã«å¯¾ã—ã¦ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã“ã¨ã‚’æœ›ã‚“ã§ã„ã¾ã›ã‚“ã€‚ãƒ¦ãƒ¼ã‚¶ãŒã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆã«ä½•ã‹ã‚’å…¥ã‚Œã¦ã€`numberOfItems` ãŒå¤‰åŒ–ã—ã¦ã‚‚ã€ãã‚Œã¯ãƒ¦ãƒ¼ã‚¶ãŒå†ã³ãƒšãƒ¼ã‚¸ã‚’è¨ªã‚ŒãŸã“ã¨ã‚’*æ„å‘³ã—ãªã„*ã€‚ã¤ã¾ã‚Šã€*ãƒšãƒ¼ã‚¸ã‚’è¨ªã‚ŒãŸ*ã¨ã„ã†ã“ã¨ã¯ã€ã‚ã‚‹æ„å‘³ã§"ã‚¤ãƒ™ãƒ³ãƒˆ"ãªã®ã§ã™ã€‚ã‚ã‚‹ç¬é–“ã«èµ·ã“ã‚‹ã®ã§ã™ã€‚

ã‚³ãƒ¼ãƒ‰ã‚’ 2 ã¤ã«åˆ†å‰²ã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼š

```js {5-7,10}
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // âœ… å…¨ã¦ã®ä¾å­˜å€¤ãŒå®£è¨€ã•ã‚Œã¦ã„ã¾ã™
  // ...
}
```

ã“ã“ã§ã€`onVisit` ã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã§ã™ã€‚ã“ã®ä¸­ã®ã‚³ãƒ¼ãƒ‰ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ãŸã‚ã€`numberOfItems`ï¼ˆã¾ãŸã¯ä»–ã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ï¼ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã‚‚ã€å¤‰æ›´æ™‚ã«å‘¨å›²ã®ã‚³ãƒ¼ãƒ‰ãŒå†å®Ÿè¡Œã•ã‚Œã‚‹å¿ƒé…ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ä¸€æ–¹ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãã®ã‚‚ã®ã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã¾ã¾ã§ã™ã€‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸­ã®ã‚³ãƒ¼ãƒ‰ã¯ `url` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ç•°ãªã‚‹ `url` ã§å†ãƒ¬ãƒ³ãƒ€ãƒ¼ã™ã‚‹ãŸã³ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå†å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã®çµæœã€`onVisit` ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

ãã®çµæœã€`url` ã®å¤‰æ›´ã”ã¨ã« `logVisit` ãŒå‘¼ã³å‡ºã•ã‚Œã€å¸¸ã«æœ€æ–°ã® `numberOfItems` ã‚’èª­ã¿å–ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ãŸã ã—ã€`numberOfItems` ãŒç‹¬è‡ªã«å¤‰åŒ–ã—ã¦ã‚‚ã€ã‚³ãƒ¼ãƒ‰ã®å†å®Ÿè¡Œã«ã¯è‡³ã‚Šã¾ã›ã‚“ã€‚

<Note>

å¼•æ•°ãªã—ã§ `onVisit()` ã‚’å‘¼ã³å‡ºã—ã€ãã®ä¸­ã® `url` ã‚’èª­ã¿å–ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã©ã†ã‹ç–‘å•ã«æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼š

```js {2,6}
  const onVisit = useEffectEvent(() => {
    logVisit(url, numberOfItems);
  });

  useEffect(() => {
    onVisit();
  }, [url]);
```

ã“ã‚Œã§ã‚‚ã„ã„ã®ã§ã™ãŒã€ã“ã® `url` ã‚’æ˜ç¤ºçš„ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã«æ¸¡ã™æ–¹ãŒã„ã„ã§ã—ã‚‡ã†ã€‚**ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã®å¼•æ•°ã¨ã—ã¦ `url` ã‚’æ¸¡ã™ã“ã¨ã§ã€ç•°ãªã‚‹ `url` ã‚’æŒã¤ãƒšãƒ¼ã‚¸ã‚’è¨ªå•ã™ã‚‹ã“ã¨ãŒã€ãƒ¦ãƒ¼ã‚¶ã®è¦–ç‚¹ã‹ã‚‰è¦‹ã‚‹ã¨åˆ¥ã®"ã‚¤ãƒ™ãƒ³ãƒˆ"ã‚’æ§‹æˆã—ã¦ã„ã‚‹ã¨ä¼ãˆã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚**`visitedUrl` ã¯ã€èµ·ã“ã£ãŸ"ã‚¤ãƒ™ãƒ³ãƒˆ"ã®*ä¸€éƒ¨*ãªã®ã§ã™ï¼š

```js {1-2,6}
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]);
```

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã§ `visitedUrl` ã‚’æ˜ç¤ºçš„ã«"è¦æ±‚"ã™ã‚‹ã®ã§ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾å­˜é…åˆ—ã‹ã‚‰èª¤ã£ã¦ `url` ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ããªããªã‚Šã¾ã—ãŸã€‚ã‚‚ã—ã€`url` ã®ä¾å­˜å€¤ã‚’å‰Šé™¤ã—ã¦ã—ã¾ã†ã¨ï¼ˆåˆ¥ã€…ã®ãƒšãƒ¼ã‚¸ã¸ã®è¨ªå•ãŒ 1 ã¤ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¦ã—ã¾ã†ï¼‰ã€ãƒªãƒ³ã‚¿ã¯ãã‚Œã«ã¤ã„ã¦è­¦å‘Šã‚’ç™ºã—ã¾ã™ã€‚`onVisit` ãŒ `url` ã«é–¢ã—ã¦åå¿œçš„ã§ã‚ã‚‹ã“ã¨ã‚’æœŸå¾…ã™ã‚‹ã®ã§ã€`url` ã‚’å†…éƒ¨ã§èª­ã¿è¾¼ã‚€ä»£ã‚ã‚Šã«ï¼ˆåå¿œçš„ã§ãªã„ï¼‰ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ*ã‹ã‚‰*ãã‚Œã‚’æ¸¡ã—ã¾ã™ã€‚

ã“ã‚Œã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸­ã«éåŒæœŸã®ãƒ­ã‚¸ãƒƒã‚¯ãŒã‚ã‚‹å ´åˆã«ç‰¹ã«é‡è¦ã«ãªã‚Šã¾ã™ï¼š

```js {6,8}
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    setTimeout(() => {
      onVisit(url);
    }, 5000); // è¨ªå•ãƒ­ã‚°ã®é…å»¶
  }, [url]);
```

ã“ã“ã§ã€`onVisit` å†…ã® `url` ã¯*æœ€æ–°*ã® `url`ï¼ˆæ—¢ã«å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰ã«å¯¾å¿œã—ã€`visitedUrl` ã¯ã“ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆãŠã‚ˆã³ã“ã® `onVisit` ã‚³ãƒ¼ãƒ«ï¼‰ã‚’æœ€åˆã«å®Ÿè¡Œã•ã›ãŸ `url` ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

</Note>

<DeepDive>

#### ä»£ã‚ã‚Šã«ä¾å­˜æ€§ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã—ã¦ã‚‚ã„ã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ {/*is-it-okay-to-suppress-the-dependency-linter-instead*/}

æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã§ã¯ã€ã“ã®ã‚ˆã†ã« lint ãƒ«ãƒ¼ãƒ«ãŒæŠ‘åˆ¶ã•ã‚Œã¦ã„ã‚‹ã®ã‚’è¦‹ã‹ã‘ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼š

```js {7-9}
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
    // ğŸ”´ ã“ã®ã‚ˆã†ã«ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã¯é¿ã‘ã¦ãã ã•ã„ï¼š
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [url]);
  // ...
}
```

`useEffectEvent` ãŒ React ã®å®‰å®šã—ãŸä¸€éƒ¨ã¨ãªã£ãŸå¾Œã€**æ±ºã—ã¦ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã—ãªã„**ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

ãƒ«ãƒ¼ãƒ«ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã®æœ€åˆã®æ¬ ç‚¹ã¯ã€ã‚³ãƒ¼ãƒ‰ã«å°å…¥ã—ãŸæ–°ã—ã„ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªä¾å­˜é…åˆ—ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒ"åå¿œã™ã‚‹"å¿…è¦ãŒã‚ã‚‹ã¨ãã«ã€React ãŒè­¦å‘Šã‚’ç™ºã—ãªããªã‚‹ã“ã¨ã§ã™ã€‚å…ˆã»ã©ã®ä¾‹ã§ã¯ã€ä¾å­˜é…åˆ—ã« `url` ã‚’è¿½åŠ ã—ãŸã®ã¯ã€React ãŒãã‚Œã‚’ã™ã‚‹ã‚ˆã†æ€ã„å‡ºã•ã›ã¦ãã‚ŒãŸã‹ã‚‰ã§ã™ã€‚ãƒªãƒ³ã‚¿ã‚’ç„¡åŠ¹ã«ã™ã‚‹ã¨ã€ä»Šå¾Œãã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç·¨é›†ã™ã‚‹éš›ã«ã€ãã®ã‚ˆã†ãªãƒªãƒã‚¤ãƒ³ãƒ€ã‚’å—ã‘å–ã‚‹ã“ã¨ãŒã§ããªããªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ãƒã‚°ã«ã¤ãªãŒã‚Šã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã§ç™ºç”Ÿã™ã‚‹ç´›ã‚‰ã‚ã—ã„ãƒã‚°ã®ä¸€ä¾‹ã§ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€`handleMove` é–¢æ•°ã¯ã€ãƒ‰ãƒƒãƒˆãŒã‚«ãƒ¼ã‚½ãƒ«ã«å¾“ã†ã¹ãã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«ã€ç¾åœ¨ã® `canMove` state å¤‰æ•°ã®å€¤ã‚’èª­ã‚€ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€`handleMove` ã®å†…éƒ¨ã§ã¯ `canMove` ã¯å¸¸ã« `true` ã§ã™ã€‚

ãªãœã‹ã‚ã‹ã‚Šã¾ã™ã‹ï¼Ÿ

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

ã“ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œã¯ã€ä¾å­˜æ€§ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚æŠ‘åˆ¶ã‚’è§£é™¤ã™ã‚‹ã¨ã€ã“ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ `handleMove` é–¢æ•°ã«ä¾å­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ç†ã«ã‹ãªã£ã¦ã„ã¾ã™ã€‚ãªãœãªã‚‰ã°ã€`handleMove` ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ¬ä½“ã®å†…éƒ¨ã§å®£è¨€ã•ã‚Œã‚‹ãŸã‚ã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã™ã¹ã¦ã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã¯ã€ä¾å­˜å€¤ã¨ã—ã¦æŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ãŒã€ãã†ã§ãªã‘ã‚Œã°æ™‚é–“ã®çµŒéã¨ã¨ã‚‚ã«é™³è…åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼

å…ƒã®ã‚³ãƒ¼ãƒ‰ã®ä½œè€…ã¯ã€React ã«å¯¾ã—ã¦ã€Œã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã©ã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ã«ã‚‚ä¾å­˜ã—ãªã„ï¼ˆ`[]`ï¼‰ã€ã¨ "å˜˜"ã‚’ã¤ã„ã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€React ã¯ `canMove` ãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å†åŒæœŸã•ã›ãªã‹ã£ãŸã®ã§ã™ï¼ˆ`handleMove` ã«é–¢ã—ã¦ã‚‚ï¼‰ã€‚React ã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å†åŒæœŸã—ãªã‹ã£ãŸãŸã‚ã€ãƒªã‚¹ãƒŠã¨ã—ã¦ã‚¢ã‚¿ãƒƒãƒã•ã‚Œã‚‹ `handleMove` ã¯ã€åˆæœŸãƒ¬ãƒ³ãƒ€ãƒ¼æ™‚ã«ä½œæˆã•ã‚ŒãŸ `handleMove` é–¢æ•°ã¨ãªã‚Šã¾ã™ã€‚åˆæœŸãƒ¬ãƒ³ãƒ€ãƒ¼æ™‚ã«ã¯ `canMove` ã¯ `true` ã§ã‚ã£ãŸãŸã‚ã€åˆæœŸãƒ¬ãƒ³ãƒ€ãƒ¼æ™‚ã® `handleMove` ã¯æ°¸é ã«ãã®å€¤ã‚’è¦‹ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

**ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ãŒãªã‘ã‚Œã°ã€é™³è…åŒ–ã—ãŸå€¤ã§å•é¡ŒãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**

`useEffectEvent` ã‚’ä½¿ãˆã°ã€ãƒªãƒ³ã‚¿ã«"å˜˜"ã‚’ã¤ãå¿…è¦ã¯ãªãã€æœŸå¾…é€šã‚Šã«ã‚³ãƒ¼ãƒ‰ãŒå‹•ãã¾ã™ï¼š

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

```css
body {
  height: 200px;
}
```

</Sandpack>

ã“ã‚Œã¯ã€`useEffectEvent` ãŒ*å¸¸ã«*æ­£ã—ã„è§£æ±ºç­–ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ãŸããªã„ã‚³ãƒ¼ãƒ‰è¡Œã«ã®ã¿é©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸Šè¨˜ã®ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ã§ã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ãŒ `canMove` ã«é–¢ã—ã¦åå¿œçš„ã§ã‚ã‚‹ã“ã¨ã‚’æœ›ã‚“ã§ã„ã¾ã›ã‚“ã§ã—ãŸã€‚ãã®ãŸã‚ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ãŒç†ã«ã‹ãªã£ã¦ã„ã¾ã™ã€‚

ãƒªãƒ³ã‚¿ã‚’æŠ‘åˆ¶ã™ã‚‹ä»–ã®æ­£ã—ã„æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€[ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾å­˜é–¢ä¿‚ã‚’å‰Šé™¤ã™ã‚‹](/learn/removing-effect-dependencies)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

</DeepDive>

### ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã®åˆ¶é™ã«ã¤ã„ã¦ {/*limitations-of-effect-events*/}

<Wip>

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã¾ã å®‰å®šç‰ˆã® React ã§**ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¦ã„ãªã„å®Ÿé¨“çš„ãª API** ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚

</Wip>

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ä½¿ã„æ–¹ãŒéå¸¸ã«é™å®šã•ã‚Œã¦ã„ã¾ã™ï¼š

* **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†…éƒ¨ã‹ã‚‰ã—ã‹å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚**
* **ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚„ãƒ•ãƒƒã‚¯ã«æ¸¡ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚**

ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’å®£è¨€ã—ã¦æ¸¡ã•ãªã„ã§ãã ã•ã„ï¼š

```js {4-6,8}
function Timer() {
  const [count, setCount] = useState(0);

  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });

  useTimer(onTick, 1000); // ğŸ”´ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¸¡ã™ã“ã¨ã‚’é¿ã‘ã¦ãã ã•ã„

  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay, callback]); // ä¾å­˜é…åˆ—ã§ "callback" ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ã‚ã‚Š
}
```

ãã®ä»£ã‚ã‚Šã«ã€å¸¸ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã™ãéš£ã§å®£è¨€ã—ã¦ãã ã•ã„ï¼š

```js {10-12,16,21}
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  const onTick = useEffectEvent(() => {
    callback();
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // âœ… Good: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†…éƒ¨ã§ã®ã¿å‘¼ã³å‡ºã•ã‚Œã‚‹
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay]); // ä¾å­˜é…åˆ—ã« "onTick" ï¼ˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆï¼‰ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒãªã„
}
```

ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ã®ä¸­ã§åå¿œã—ãªã„"ãƒ”ãƒ¼ã‚¹"ã§ã™ã€‚ãã‚Œã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®éš£ã«ç½®ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

<Recap>

- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã¯ã€ç‰¹å®šã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã«å¿œç­”ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
- åŒæœŸãŒå¿…è¦ãªã¨ãã¯ã„ã¤ã§ã‚‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©å†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†…ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã™ã€‚
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®éãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã«ç§»å‹•ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã›ã‚‹ã®ã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†…éƒ¨ã ã‘ã§ã™ã€‚
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚„ Hooks ã«æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚

</Recap>

<Challenges>

#### æ›´æ–°ã•ã‚Œãªã„å¤‰æ•°ã‚’ä¿®æ­£ã™ã‚‹ {/*fix-a-variable-that-doesnt-update*/}

ã“ã® `Timer` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€1 ç§’ã”ã¨ã«å¢—åŠ ã™ã‚‹ `count` state å¤‰æ•°ã‚’ä¿æŒã—ã¾ã™ã€‚å¢—åŠ ã™ã‚‹å€¤ã¯ã€`increment` state å¤‰æ•°ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚ãƒ—ãƒ©ã‚¹ãƒœã‚¿ãƒ³ã¨ãƒã‚¤ãƒŠã‚¹ãƒœã‚¿ãƒ³ã§ `increment` å¤‰æ•°ã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚

ã—ã‹ã—ã€ãƒ—ãƒ©ã‚¹ãƒœã‚¿ãƒ³ã‚’ä½•åº¦ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚‚ã€ã‚«ã‚¦ãƒ³ã‚¿ã¯ 1 ç§’ã”ã¨ã« 1 ã¤ãšã¤å¢—ãˆã¦ã„ãã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã®ä½•ãŒå•é¡Œãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ ãªãœã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰å†…éƒ¨ã§ã¯ `increment` ãŒå¸¸ã« 1 ã«ç­‰ã—ã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ é–“é•ã„ã‚’è¦‹ã¤ã‘ã¦ä¿®æ­£ã—ã¾ã—ã‚‡ã†ã€‚

<Hint>

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ç›´ã™ã«ã¯ã€ãƒ«ãƒ¼ãƒ«ã‚’å®ˆã‚Œã°ã„ã„ã®ã§ã™ã€‚

</Hint>

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

```css
button { margin: 10px; }
```

</Sandpack>

<Solution>

ä¾‹ã«ã‚ˆã£ã¦ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒã‚°ã‚’æ¢ã™ã¨ãã¯ã€ãƒªãƒ³ã‚¿æŠ‘åˆ¶ã®æ¤œç´¢ã‹ã‚‰å§‹ã‚ã¦ãã ã•ã„ã€‚

æŠ‘åˆ¶ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹ã¨ã€React ã¯ã“ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ãŒ `increment` ã«ä¾å­˜ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ•™ãˆã¦ãã‚Œã¾ã™ãŒã€ã“ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–å€¤ï¼ˆ`[]`ï¼‰ã«ä¾å­˜ã—ã¦ã„ãªã„ã¨ä¸»å¼µã™ã‚‹ã“ã¨ã§ React ã«"å˜˜ã‚’ã¤ã„ãŸ"ã®ã§ã™ã€‚ä¾å­˜é…åˆ—ã« `increment` ã‚’è¿½åŠ ã—ã¾ã™ï¼š

<Sandpack>

```js
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, [increment]);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

```css
button { margin: 10px; }
```

</Sandpack>

Now, when `increment` changes, React will re-synchronize your Effect, which will restart the interval.

</Solution>

#### Fix a freezing counter {/*fix-a-freezing-counter*/}

This `Timer` component keeps a `count` state variable which increases every second. The value by which it's increasing is stored in the `increment` state variable, which you can control it with the plus and minus buttons. For example, try pressing the plus button nine times, and notice that the `count` now increases each second by ten rather than by one.

There is a small issue with this user interface. You might notice that if you keep pressing the plus or minus buttons faster than once per second, the timer itself seems to pause. It only resumes after a second passes since the last time you've pressed either button. Find why this is happening, and fix the issue so that the timer ticks on *every* second without interruptions.

<Hint>

It seems like the Effect which sets up the timer "reacts" to the `increment` value. Does the line that uses the current `increment` value in order to call `setCount` really need to be reactive?

</Hint>

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, [increment]);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

```css
button { margin: 10px; }
```

</Sandpack>

<Solution>

The issue is that the code inside the Effect uses the `increment` state variable. Since it's a dependency of your Effect, every change to `increment` causes the Effect to re-synchronize, which causes the interval to clear. If you keep clearing the interval every time before it has a chance to fire, it will appear as if the timer has stalled.

To solve the issue, extract an `onTick` Effect Event from the Effect:

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  const onTick = useEffectEvent(() => {
    setCount(c => c + increment);
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick();
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```


```css
button { margin: 10px; }
```

</Sandpack>

Since `onTick` is an Effect Event, the code inside it isn't reactive. The change to `increment` does not trigger any Effects.

</Solution>

#### Fix a non-adjustable delay {/*fix-a-non-adjustable-delay*/}

In this example, you can customize the interval delay. It's stored in a `delay` state variable which is updated by two buttons. However, even if you press the "plus 100 ms" button until the `delay` is 1000 milliseconds (that is, a second), you'll notice that the timer still increments very fast (every 100 ms). It's as if your changes to the `delay` are ignored. Find and fix the bug.

<Hint>

Code inside Effect Events is not reactive. Are there cases in which you would _want_ the `setInterval` call to re-run?

</Hint>

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);
  const [delay, setDelay] = useState(100);

  const onTick = useEffectEvent(() => {
    setCount(c => c + increment);
  });

  const onMount = useEffectEvent(() => {
    return setInterval(() => {
      onTick();
    }, delay);
  });

  useEffect(() => {
    const id = onMount();
    return () => {
      clearInterval(id);
    }
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
      <p>
        Increment delay:
        <button disabled={delay === 100} onClick={() => {
          setDelay(d => d - 100);
        }}>â€“100 ms</button>
        <b>{delay} ms</b>
        <button onClick={() => {
          setDelay(d => d + 100);
        }}>+100 ms</button>
      </p>
    </>
  );
}
```


```css
button { margin: 10px; }
```

</Sandpack>

<Solution>

The problem with the above example is that it extracted an Effect Event called `onMount` without considering what the code should actually be doing. You should only extract Effect Events for a specific reason: when you want to make a part of your code non-reactive. However, the `setInterval` call *should* be reactive with respect to the `delay` state variable. If the `delay` changes, you want to set up the interval from scratch! To fix this code, pull all the reactive code back inside the Effect:

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);
  const [delay, setDelay] = useState(100);

  const onTick = useEffectEvent(() => {
    setCount(c => c + increment);
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick();
    }, delay);
    return () => {
      clearInterval(id);
    }
  }, [delay]);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
      <p>
        Increment delay:
        <button disabled={delay === 100} onClick={() => {
          setDelay(d => d - 100);
        }}>â€“100 ms</button>
        <b>{delay} ms</b>
        <button onClick={() => {
          setDelay(d => d + 100);
        }}>+100 ms</button>
      </p>
    </>
  );
}
```

```css
button { margin: 10px; }
```

</Sandpack>

In general, you should be suspicious of functions like `onMount` that focus on the *timing* rather than the *purpose* of a piece of code. It may feel "more descriptive" at first but it obscures your intent. As a rule of thumb, Effect Events should correspond to something that happens from the *user's* perspective. For example, `onMessage`, `onTick`, `onVisit`, or `onConnected` are good Effect Event names. Code inside them would likely not need to be reactive. On the other hand, `onMount`, `onUpdate`, `onUnmount`, or `onAfterRender` are so generic that it's easy to accidentally put code that *should* be reactive into them. This is why you should name your Effect Events after *what the user thinks has happened,* not when some code happened to run.

</Solution>

#### Fix a delayed notification {/*fix-a-delayed-notification*/}

When you join a chat room, this component shows a notification. However, it doesn't show the notification immediately. Instead, the notification is artificially delayed by two seconds so that the user has a chance to look around the UI.

This almost works, but there is a bug. Try changing the dropdown from "general" to "travel" and then to "music" very quickly. If you do it fast enough, you will see two notifications (as expected!) but they will *both* say "Welcome to music".

Fix it so that when you switch from "general" to "travel" and then to "music" very quickly, you see two notifications, the first one being "Welcome to travel" and the second one being "Welcome to music". (For an additional challenge, assuming you've *already* made the notifications show the correct rooms, change the code so that only the latter notification is displayed.)

<Hint>

Your Effect knows which room it connected to. Is there any information that you might want to pass to your Effect Event?

</Hint>

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Welcome to ' + roomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      setTimeout(() => {
        onConnected();
      }, 2000);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

```js chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Only "connected" event is supported.');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

```js notifications.js hidden
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```css
label { display: block; margin-top: 10px; }
```

</Sandpack>

<Solution>

Inside your Effect Event, `roomId` is the value *at the time Effect Event was called.*

Your Effect Event is called with a two second delay. If you're quickly switching from the travel to the music room, by the time the travel room's notification shows, `roomId` is already `"music"`. This is why both notifications say "Welcome to music".

To fix the issue, instead of reading the *latest* `roomId` inside the Effect Event, make it a parameter of your Effect Event, like `connectedRoomId` below. Then pass `roomId` from your Effect by calling `onConnected(roomId)`:

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(connectedRoomId => {
    showNotification('Welcome to ' + connectedRoomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      setTimeout(() => {
        onConnected(roomId);
      }, 2000);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

```js chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Only "connected" event is supported.');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

```js notifications.js hidden
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```css
label { display: block; margin-top: 10px; }
```

</Sandpack>

The Effect that had `roomId` set to `"travel"` (so it connected to the `"travel"` room) will show the notification for `"travel"`. The Effect that had `roomId` set to `"music"` (so it connected to the `"music"` room) will show the notification for `"music"`. In other words, `connectedRoomId` comes from your Effect (which is reactive), while `theme` always uses the latest value.

To solve the additional challenge, save the notification timeout ID and clear it in the cleanup function of your Effect:

<Sandpack>

```json package.json hidden
{
  "dependencies": {
    "react": "experimental",
    "react-dom": "experimental",
    "react-scripts": "latest",
    "toastify-js": "1.12.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

```js
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(connectedRoomId => {
    showNotification('Welcome to ' + connectedRoomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    let notificationTimeoutId;
    connection.on('connected', () => {
      notificationTimeoutId = setTimeout(() => {
        onConnected(roomId);
      }, 2000);
    });
    connection.connect();
    return () => {
      connection.disconnect();
      if (notificationTimeoutId !== undefined) {
        clearTimeout(notificationTimeoutId);
      }
    };
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

```js chat.js
export function createConnection(serverUrl, roomId) {
  // A real implementation would actually connect to the server
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Only "connected" event is supported.');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

```js notifications.js hidden
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

```css
label { display: block; margin-top: 10px; }
```

</Sandpack>

This ensures that already scheduled (but not yet displayed) notifications get cancelled when you change rooms.

</Solution>

</Challenges>
